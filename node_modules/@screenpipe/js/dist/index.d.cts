import { E as ElementSelector, a as ElementInfo, b as ElementStats, c as ElementPosition, d as ElementSize, S as Settings, N as NotificationOptions, e as ScreenpipeQueryParams, f as ScreenpipeResponse } from './types--V_ysljQ.cjs';
export { q as AIPreset, n as AIProviderType, m as ActionResponse, A as AudioContent, w as ClickElementRequest, h as ContentItem, C as ContentType, o as EmbeddedLLMConfig, v as EventStreamResponse, F as FindElementsRequest, k as InboxMessage, l as InboxMessageAction, I as InputAction, i as InputControlResponse, j as NotificationAction, O as OCRContent, P as PaginationInfo, s as ParsedConfig, r as PipeConfig, g as Speaker, T as TranscriptionChunk, t as TranscriptionStreamResponse, x as TypeTextRequest, U as UiContent, p as User, V as VisionEvent, u as VisionStreamResponse } from './types--V_ysljQ.cjs';
import { SettingsManager } from './SettingsManager.cjs';
import { InboxManager } from './InboxManager.cjs';

type Result<T> = {
    success: true;
    data: T;
} | {
    success: false;
    error: any;
};
declare class PipesManager {
    list(): Promise<Result<string[]>>;
    download(url: string): Promise<Result<Record<string, any>>>;
    enable(pipeId: string): Promise<boolean>;
    disable(pipeId: string): Promise<boolean>;
    update(pipeId: string, config: {
        [key: string]: string;
    }): Promise<boolean>;
    info(pipeId: string): Promise<Result<Record<string, any>>>;
    downloadPrivate(url: string, pipeName: string, pipeId: string): Promise<Result<Record<string, any>>>;
    delete(pipeId: string): Promise<boolean>;
}

interface ClickResult {
    method: "AXPress" | "AXClick" | "MouseSimulation";
    coordinates?: [number, number];
    details: string;
}
interface GetTextMetadata {
    extractionTimeMs: number;
    elementCount: number;
    appName: string;
    timestampUtc: string;
}
interface TextResponse {
    success: boolean;
    text: string;
    metadata?: GetTextMetadata;
}
interface InteractableElement {
    index: number;
    role: string;
    interactability: string;
    text: string;
    position?: ElementPosition;
    size?: ElementSize;
    elementId?: string;
}
interface InteractableElementsResponse {
    elements: InteractableElement[];
    stats: ElementStats;
}
declare class Operator {
    private baseUrl;
    pixel: {
        type: (text: string) => Promise<boolean>;
        press: (key: string) => Promise<boolean>;
        moveMouse: (x: number, y: number) => Promise<boolean>;
        click: (button: "left" | "right" | "middle") => Promise<boolean>;
    };
    constructor(baseUrl?: string);
    private sendInputControl;
    /**
     * Find UI elements on screen matching the given criteria
     *
     * @example
     * // Find all buttons in Chrome
     * const buttons = await pipe.operator.locator({
     *   app: "Chrome",
     *   role: "button"
     * }).all();
     *
     * You can also use MacOS accessibility roles (eg. "AXButton", "AXTextField", "AXCheckbox", etc.), check MacOS Accessibility App to see the list of roles
     *
     * @example
     * // Find a specific element by id
     * const element = await pipe.operator.locator({
     *   app: "WhatsApp",
     *   id: "1234"
     * }).first();
     */
    locator(options: {
        app: string;
        window?: string;
        role?: string;
        id?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
    }): ElementLocator;
    /**
     * Find and click an element on screen
     *
     * @returns Detailed information about the click operation
     *
     * @example
     * // Click a button with text "Submit" and get details about how it was clicked
     * const result = await pipe.operator.click({
     *   app: "Chrome",
     *   id: "1234"
     * });
     * console.log(`Click method: ${result.method}, Details: ${result.details}`);
     */
    click(options: {
        id: string;
        app: string;
        window?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
    }): Promise<ClickResult>;
    /**
     * Find an element and type text into it
     *
     * @example
     * // Type "hi darling" into the message field
     * await pipe.operator.fill({
     *   app: "WhatsApp",
     *   id: "1234",
     *   value: "hi darling"
     * });
     */
    fill(options: {
        app: string;
        id?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
        value: string;
    }): Promise<any>;
    /**
     * Get locator for elements with the specified role (eg. "button", "textfield", "checkbox", etc.)
     * You can also use MacOS accessibility roles (eg. "AXButton", "AXTextField", "AXCheckbox", etc.), check MacOS Accessibility App to see the list of roles
     *
     * @example
     * // Find element(s) with role "button" in Chrome
     * const buttons = await pipe.operator.getByRole('button', { app: 'Chrome' });
     */
    getByRole(role: string, options?: {
        app?: string;
        window?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
    }): ElementLocator;
    /**
     * Get locator for elements with the specified id
     *
     * @example
     * // Find an element with a specific ID
     * await pipe.operator.getById('submit-button', { app: 'Chrome' })
     */
    getById(id: string, options?: {
        app?: string;
        window?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
    }): ElementLocator;
    /**
     * get text on the screen
     *
     * @returns Detailed information about get_text operation
     *
     * @example
     * // Gets all the text from an app
     * await browserPipe.operator
     *   .getText({
     *     app: app,
     *   });
     */
    getText(options: {
        app: string;
        window?: string;
        maxDepth?: number;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
    }): Promise<TextResponse>;
    /**
     * get text on the screen
     *
     * @returns Detailed information about get_text operation
     *
     * @example
     * // Gets all the text from an app
     * await browserPipe.operator
     *   .getInteractableElements({
     *     app: app,
     *   });
     */
    getInteractableElements(options: {
        app: string;
        window?: string;
        withTextOnly?: boolean;
        interactableOnly?: boolean;
        includeSometimesInteractable?: boolean;
        maxElements?: number;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
    }): Promise<InteractableElementsResponse>;
    /**
     * Click an element by its index from the cached element list
     *
     * @example
     * // Click the element at index 5
     * await pipe.operator.clickByIndex(5);
     */
    clickByIndex(index: number): Promise<boolean>;
    /**
     * Type text into an element by its index from the cached element list
     *
     * @example
     * // Type "hello world" into the element at index 3
     * await pipe.operator.typeByIndex(3, "hello world");
     */
    typeByIndex(index: number, text: string): Promise<boolean>;
    /**
     * Find an element and press a key combination on it
     *
     * @example
     * // Press Tab key on a text field
     * await pipe.operator.pressKey({
     *   app: "Chrome",
     *   label: "Email",
     *   key: "tab"
     * });
     *
     * @example
     * // Press keyboard shortcut Command+C on a text field
     * await pipe.operator.pressKey({
     *   app: "Safari",
     *   role: "textfield",
     *   key: "cmd+c"
     * });
     */
    pressKey(options: {
        app: string;
        window?: string;
        id?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
        key: string;
    }): Promise<any>;
    /**
     * Press a key combination on an element by its index from the cached element list
     *
     * @example
     * // Press Tab key on the element at index 5
     * await pipe.operator.pressKeyByIndex(5, "tab");
     *
     * @example
     * // Press Command+A (Select All) on the element at index 2
     * await pipe.operator.pressKeyByIndex(2, "cmd+a");
     */
    pressKeyByIndex(index: number, keyCombo: string): Promise<boolean>;
    /**
     * Open an application by name
     *
     * @example
     * // Open Chrome browser
     * await pipe.operator.openApplication("Chrome");
     */
    openApplication(applicationName: string): Promise<boolean>;
    /**
     * Open a URL in the specified browser or default browser
     *
     * @example
     * // Open URL in default browser
     * await pipe.operator.openUrl("https://example.com");
     *
     * @example
     * // Open URL in specified browser
     * await pipe.operator.openUrl("https://example.com", "Chrome");
     */
    openUrl(url: string, browser?: string): Promise<boolean>;
    /**
     * Scroll an element in the specified direction
     *
     * @example
     * // Scroll down in a scrollable element
     * await pipe.operator.scroll({
     *   app: "Chrome",
     *   id: "content-area",
     *   direction: "down",
     *   amount: 100
     * });
     */
    scroll(options: {
        app: string;
        id?: string;
        window?: string;
        useBackgroundApps?: boolean;
        activateApp?: boolean;
        direction: "up" | "down" | "left" | "right";
        amount: number;
    }): Promise<boolean>;
}
declare class ElementLocator {
    private baseUrl;
    private selector;
    constructor(baseUrl: string, selector: ElementSelector);
    /**
     * Get the first element matching the selector
     */
    first(maxDepth?: number): Promise<ElementInfo | null>;
    /**
     * Get all elements matching the selector
     */
    all(maxResults?: number, maxDepth?: number): Promise<ElementInfo[]>;
    /**
     * Click the first element matching the selector
     *
     * @returns Detailed information about the click operation
     */
    click(): Promise<ClickResult>;
    /**
     * Fill the first element matching the selector with text
     */
    fill(text: string): Promise<boolean>;
    /**
     * Check if an element matching the selector exists
     */
    exists(): Promise<boolean>;
    /**
     * Wait for an element matching the selector to appear
     */
    waitFor(options?: {
        timeout?: number;
    }): Promise<ElementInfo | null>;
    /**
     * Press a key combination on the first element matching the selector
     *
     * @param keyCombo The key or key combination to press (e.g., "tab", "cmd+c", "shift+enter")
     * @returns Whether the operation was successful
     */
    pressKey(keyCombo: string): Promise<boolean>;
    /**
     * Scroll the first element matching the selector
     *
     * @param direction The direction to scroll: "up", "down", "left", or "right"
     * @param amount The amount to scroll in pixels
     * @returns Whether the scroll operation was successful
     */
    scroll(direction: "up" | "down" | "left" | "right", amount: number): Promise<boolean>;
}

declare function getDefaultSettings(): Settings;

declare class NodePipe {
    private analyticsInitialized;
    private analyticsEnabled;
    settings: SettingsManager;
    inbox: InboxManager;
    pipes: PipesManager;
    operator: Operator;
    sendDesktopNotification(options: NotificationOptions): Promise<boolean>;
    /**
     * Query Screenpipe for content based on various filters.
     *
     * @param params - Query parameters for filtering Screenpipe content
     * @returns Promise resolving to the Screenpipe response or null
     *
     * @example
     * // Basic search for recent browser activity on a specific website
     * const githubActivity = await pipe.queryScreenpipe({
     *   browserUrl: "github.com",
     *   contentType: "ocr",
     *   limit: 20,
     *   includeFrames: true
     * });
     *
     * @example
     * // Search for specific text on a particular website with date filters
     * const searchResults = await pipe.queryScreenpipe({
     *   q: "authentication",
     *   browserUrl: "auth0.com",
     *   appName: "Chrome",
     *   contentType: "ocr",
     *   startTime: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
     *   endTime: new Date().toISOString(),
     *   limit: 50
     * });
     *
     * @example
     * // Track history of visits to a specific web application
     * type VisitSession = {
     *   timestamp: string;
     *   title: string;
     *   textContent: string;
     *   imageData?: string;
     * };
     *
     * async function getAppUsageHistory(domain: string): Promise<VisitSession[]> {
     *   try {
     *     const results = await pipe.queryScreenpipe({
     *       browserUrl: domain,
     *       contentType: "ocr",
     *       includeFrames: true,
     *       limit: 100,
     *       startTime: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString() // last 30 days
     *     });
     *
     *     return results.data
     *       .filter(item => item.type === "OCR")
     *       .map(item => {
     *         const ocrItem = item.content as OCRContent;
     *         return {
     *           timestamp: ocrItem.timestamp,
     *           title: ocrItem.windowName || '',
     *           textContent: ocrItem.text,
     *           imageData: ocrItem.frame
     *         };
     *       });
     *   } catch (error) {
     *     console.error("Failed to retrieve app usage history:", error);
     *     return [];
     *   }
     * }
     *
     * @example
     * // Combining browserUrl with speaker filters for meeting recordings in browser
     * import { pipe, ContentType, ScreenpipeResponse } from '@screenpipe/js';
     *
     * interface MeetingData {
     *   url: string;
     *   speakerName: string;
     *   transcript: string;
     *   timestamp: string;
     * }
     *
     * async function getMeetingTranscripts(
     *   meetingUrl: string,
     *   speakerIds: number[]
     * ): Promise<MeetingData[]> {
     *   try {
     *     const results = await pipe.queryScreenpipe({
     *       browserUrl: meetingUrl,
     *       contentType: "audio" as ContentType,
     *       speakerIds: speakerIds,
     *       limit: 200
     *     });
     *
     *     return results.data
     *       .filter(item => item.type === "Audio")
     *       .map(item => {
     *         const audioItem = item.content;
     *         return {
     *           url: meetingUrl,
     *           speakerName: audioItem.speaker?.name || 'Unknown',
     *           transcript: audioItem.transcription,
     *           timestamp: audioItem.timestamp
     *         };
     *       });
     *   } catch (error) {
     *     console.error(`Error fetching meeting transcripts for ${meetingUrl}:`, error);
     *     return [];
     *   }
     * }
     */
    queryScreenpipe(params: ScreenpipeQueryParams): Promise<ScreenpipeResponse | null>;
    private initAnalyticsIfNeeded;
    captureEvent(eventName: string, properties?: Record<string, any>): Promise<void>;
    captureMainFeatureEvent(featureName: string, properties?: Record<string, any>): Promise<void>;
}
declare const pipe: NodePipe;

export { ElementInfo, ElementPosition, ElementSelector, ElementSize, ElementStats, NotificationOptions, ScreenpipeQueryParams, ScreenpipeResponse, Settings, getDefaultSettings, pipe };
